/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculadora.h"
#include <math.h>

resultado_calculadora *
operacion_aritmetica_1_svc(operacion arg1,  struct svc_req *rqstp)		/* Funcion que realiza las operaciones aritmeticas */
{
	static resultado_calculadora  result;
	switch (arg1.op) 
		{
		case '+':
			result.resultado_calculadora_u.resultado = (arg1.a + arg1.b);	/* Suma */
			result.errnum = 0;
			break;

		case '-':
			result.resultado_calculadora_u.resultado = arg1.a - arg1.b;		/* Resta */
			result.errnum = 0;
			break;

		case '*':
			result.resultado_calculadora_u.resultado = arg1.a * arg1.b;		/* Multiplicacion */
			result.errnum = 0;
			break;

		case '/':
			if(arg1.b == 0){
				result.errnum = 10001;	/* Error, division por cero */
				break;
			}
			result.resultado_calculadora_u.resultado = ((double)arg1.a ) / arg1.b;	/* Division */
			result.errnum = 0;
			break;
		
		case '^':
			/* Se realiza la operacion de potencia, lo hago sin usar la funcion pow para demostrar que se puede hacer sin ella
				y realizar una operacion con cierta complejidad*/
			
			double resultado_aux = 1;	
			if (arg1.b >= 0) {
				for ( int i = 0; i < arg1.b; i++) {
					resultado_aux *= arg1.a;
				}
			}
			else {
				for (int i = 0; i > arg1.b; i--) {
					resultado_aux /= arg1.a;
				}
			}
			result.resultado_calculadora_u.resultado = resultado_aux;
			result.errnum = 0;
			break;
		
		case 'r':
			result.resultado_calculadora_u.resultado = pow(arg1.b, (1/(double)arg1.a)); /* Raiz "a" del segundo valor*/
			result.errnum = 0;
			break;
		default:
			result.errnum = 10002; /* Error, operador incorrecto */
			break;
		}
	
	return &result;
}

resultado_calculadora *
operacion_trigonometrica_2_svc(operacion_t arg1,  struct svc_req *rqstp) 	/* Funcion que realiza las operaciones trigonometricas */
{
	static resultado_calculadora  result;
	switch (arg1.func) /*El enum creado sive para facilitar la forma de ver el switch*/
	{
	case SENO:
		result.resultado_calculadora_u.resultado = sin(arg1.valor); 		/* Seno */
		result.errnum = 0;
		break;
	
	case COSENO:
		result.resultado_calculadora_u.resultado = cos(arg1.valor);			/* Coseno */
		result.errnum = 0;
		break;
	
	case TANGENTE:	
		result.resultado_calculadora_u.resultado = tan(arg1.valor);			/* Tangente */
		result.errnum = 0;
		break;
	
	case COTANGENTE:
		if(tan(arg1.valor) == 0){
			result.errnum = 10003;	/* Error, la cotangente no esta declarada para estos valores*/
			break;
		}
		else{
			result.resultado_calculadora_u.resultado = (1/tan(arg1.valor));		/* Cotangente */
			result.errnum = 0;
			break;
		}

	case SECANTE:
		if(cos(arg1.valor) == 0){
			result.errnum = 10003;	/* Error, la secante no esta declarada para estos valores*/
			break;
		}
		else{
			result.resultado_calculadora_u.resultado = (1/cos(arg1.valor));		/* Secante */
			result.errnum = 0;
			break;
		}

	case COSECANTE:
		if(sin(arg1.valor) == 0){
			result.errnum = 10003;	/* Error, la cosecante no esta declarada para estos valores*/
			break;
		}
		else{
			result.resultado_calculadora_u.resultado = (1/sin(arg1.valor));		/* Cosecante */
			result.errnum = 0;
			break;
		}
	
	case ARCOSENO: 
		if(arg1.valor > 1 || arg1.valor < -1){
			result.errnum = 10003;	/* Error, el arcoseno no esta declarado para estos valores*/
			break;
		}
		else{
			result.resultado_calculadora_u.resultado = asin(arg1.valor);	/* Arcoseno */
			result.errnum = 0;
			break;
		}
	
	case ARCOCOSENO:
		if(arg1.valor > 1 || arg1.valor < -1){
			result.errnum = 10003;	/* Error, el arcocoseno no esta declarado para estos valores*/
			break;
		}
		else{
			result.resultado_calculadora_u.resultado = acos(arg1.valor);	/* Arcocoseno */
			result.errnum = 0;
			break;
		}
	
	case ARCOTANGENTE:
		result.resultado_calculadora_u.resultado = atan(arg1.valor);	/* Arcotangente */
		result.errnum = 0;
		break;

	default:
		result.errnum = 10002;	/* Error, operador incorrecto */
		break;
	}

	return &result;
}


resultado_calculadora_ecuaciones *
operacion_ecuaciones_3_svc(operacion_e arg1,  struct svc_req *rqstp) 	/* Funcion que realiza las ecuaciones de segundo grado */
{
	static resultado_calculadora_ecuaciones  result;
	double raiz = (arg1.b*arg1.b) - 4 * arg1.a * arg1.c;	/* Se calcula la raiz de la ecuacion */

	if(raiz < 0){
		result.errnum = 10004;	/* Error, raiz negativa */
	}
	else{
		result.resultado_calculadora_ecuaciones_u.res.positivo = (-arg1.b + sqrt(raiz)) / (2 * arg1.a);	/* Se calcula la raiz positiva */
		result.resultado_calculadora_ecuaciones_u.res.negativo = (-arg1.b - sqrt(raiz)) / (2 * arg1.a);	/* Se calcula la raiz negativa */
		result.errnum = 0;
	}
	return &result;
}


resultado_calculadora_vectores *
operacion_vectores_4_svc(operacion_v arg1,  struct svc_req *rqstp)	/* Funcion que realiza las operaciones con vectores */
{
	static resultado_calculadora_vectores  result;

	result.resultado_calculadora_vectores_u.resultado.vectores_val = malloc(arg1.tam * sizeof(double));		/* Se reserva la memoria */
	result.resultado_calculadora_vectores_u.resultado.vectores_len = arg1.tam;								/* Se asigna el tam */
	switch (arg1.op) 
		{
		case '+':	
			for(int i = 0; i < arg1.tam; i++){
				
				result.resultado_calculadora_vectores_u.resultado.vectores_val[i] = arg1.a.vectores_val[i] + arg1.b.vectores_val[i];	/* Suma */
			}
			result.errnum = 0;
			break;

		case '-':
			for(int i = 0; i < arg1.tam; i++){
				result.resultado_calculadora_vectores_u.resultado.vectores_val[i] = arg1.a.vectores_val[i] - arg1.b.vectores_val[i];	/* Resta */
			}
			result.errnum = 0;
			break;

		case '*':
			int p_escalar = 0;
			for(int i = 0; i < arg1.tam; i++){
				p_escalar += arg1.a.vectores_val[i] * arg1.b.vectores_val[i];	/* Calculo del producto escalar */
			}
			
			result.resultado_calculadora_vectores_u.resultado.vectores_len = 1;				/* Se asigna el tam al vector resultado */
			result.resultado_calculadora_vectores_u.resultado.vectores_val[0] = p_escalar;	/* Se guarda el resultado */
			result.errnum = 0;
			break;

		case '^':
			if(arg1.tam == 3){
				result.resultado_calculadora_vectores_u.resultado.vectores_val[0] = arg1.a.vectores_val[1] * arg1.b.vectores_val[2] - arg1.a.vectores_val[2] * arg1.b.vectores_val[1];	/* Producto vectorial[0] */
				result.resultado_calculadora_vectores_u.resultado.vectores_val[1] = arg1.a.vectores_val[2] * arg1.b.vectores_val[0] - arg1.a.vectores_val[0] * arg1.b.vectores_val[2];	/* Producto vectorial[1] */
				result.resultado_calculadora_vectores_u.resultado.vectores_val[2] = arg1.a.vectores_val[0] * arg1.b.vectores_val[1] - arg1.a.vectores_val[1] * arg1.b.vectores_val[0];	/* Producto vectorial[2] */
				result.errnum = 0;
				break;
			}
			else{
				result.errnum = 10005;	/* Error, el producto vectorial solo esta definido para vectores de 3 dimensiones */
				break;
			}
		
		default:
			result.errnum = 10002;	/* Error, operador incorrecto */
			break;
		}
	return &result;
}
